<?php
/*========================================================================*\
|| ###################################################################### ||
|| # vBulletin 5.6.0
|| # ------------------------------------------------------------------ # ||
|| # Copyright 2000-2020 MH Sub I, LLC dba vBulletin. All Rights Reserved.  # ||
|| # This file may not be redistributed in whole or significant part.   # ||
|| # ----------------- VBULLETIN IS NOT FREE SOFTWARE ----------------- # ||
|| # http://www.vbulletin.com | http://www.vbulletin.com/license.html   # ||
|| ###################################################################### ||
\*========================================================================*/

/**
 * vB_Utility_Filescanner
 *
 * @package vBulletin
 */
class vB_Utility_Hashchecker
{
	use vB_Utility_Trait_NoSerialize;


	private $stringClass;

	// Various construction options that tells us which directory we'll start scanning (and more importantly,
	// the md5 array's paths are all relative to this directory), which extensions of files to ignore, etc.
	private $checksumFilePrefix;
	private $checksumFileDir;
	private $checkedExtensions;
	private $ignoredFiles;
	private $ignoredDirs;
	private $scanRootDir;
	private $scanRootLen;
	private $algorithm; // e.g. md5, sha256

	// data pulled from/generated by processing checksum files. They are keyed
	// by the full relevant filepath (from realpath)
	private $checksums = array();
	private $expectedDirs = array();
	private $versions = array();
	private $fileSoftwareAssoc = array();
	private $scannedChecksumFiles = array();

	// We ltrim the "scanRoot" off the realpaths for our messaging.
	// Since we might call it over and over on the same directories
	// let's cache the results so we don't repeat the same substr ops
	private $relativeDirs = array();

	// Prevent circular symlinks from getting us stuck
	private $checkedDirs = array();

	// Results of file scans/compares.
	private $fileCounts = array();
	private $errors = array();
	private $skippedDirs = array();
	private $skippedFiles = array();

	// initialization errors
	private $fatalErrors;
	private $startupWarnings;

	public function __construct($options, $stringClass)
	{
		// instance of vb_utililty_string. Required early due to
		// option set/validation functions' dependency
		if ($stringClass instanceOf vB_Utility_String)
		{
			$this->stringClass = $stringClass;
		}
		else
		{
			throw new Exception('$stringClass must be an instance of vB_Utility_String');
		}

		$defaultOptions = array(
			'extensions' => array(
				'.php',
				'.xml',
				'.js',
				'.htc',
				'.css',
				'.new',
				'.style',
				'.sh',
				'.htm',
				'.html',
				'.txt',
				'.phar',
				// .htaccess, web.config
				'.htaccess', // .htaccess
				'.config', // web.config
				// static assets (images, fonts)
				'.gif',
				'.jpg',
				'.png',
				'.svg',
				'.pdf',
				// There seems to be 1 psd in jquery
				'.psd',
				'.woff',
				'.woff2',
				'.ttf',
				// extension-less, like LICENSE, README files
				'',
				// others, mostly from 3rd party libraries (e.g. log4php)
				'.pem',
				'.md',
				'.crt',
				'.vm',
				'.xslt',
				'.yml',
				'.cnf',
				'.apt',
				'.xslt',
				'.properties',
				'.ini',
				'.json',
				'.ico',
			),
			'checksumFilePrefix' => 'md5_sums_',
			'checksumFileDir' => DIR  . '/includes',
			'ignoredFiles' =>  array(
				DIR . '/../config.php',
				DIR . '/../config.php.bkp',
				DIR . '/includes/config.php',
				DIR . '/includes/config.php.new',
				DIR . '/install/install.php',
				DIR . '/install/makeconfig.php',
				DIR . '/includes/version_vbulletin.php',
				DIR . '/../.htaccess',
			),
			'ignoredDirs' => $this->getDefaultIgnoredDirs(),
			// Allowed to be missing, but checked if present on filesystem.
			'allowedMissing' => array(
				DIR . '/../htaccess.txt',
			),
			'scanRootDir' => DIR,
			'algorithm' => 'md5',
		);

		$options = array_merge($defaultOptions, $options);
		/*
		// Clean up unexpected params, ensure arrays for arrays...
		foreach ($defaultOptions AS $__key => $__val)
		{
			if (isset($options[$__key]))
			{
				if (is_array($__val) AND !is_array($options[$__key]))
				{
					$options[$__key] = array($options[$__key]);
				}

				$defaultOptions[$__key] = $options[$__key];
			}
		}
		*/

		$this->validateOptions($options);

		$this->checksumFilePrefix = $options['checksumFilePrefix'];
		$this->checksumFileDir = $options['checksumFileDir'];
		// Key by file/dir-paths so we can do isset() instead of in_array
		foreach ($options['extensions'] AS $__val)
		{
			$this->checkedExtensions[$__val] = $__val;
		}

		$this->addIgnoredFile($options['ignoredFiles']);
		$this->addIgnoredDir($options['ignoredDirs']);
		$this->addAllowedMissingFile($options['allowedMissing']);
		$this->setScanRootDir($options['scanRootDir']);

		// This will get passed into hash() later.
		// TODO: should we restrict or validate it in some way?
		$this->algorithm = $options['algorithm'];
	}

	private function getDefaultIgnoredDirs()
	{
		$defaultIgnoredDirs = array(
			DIR . '/cpstyles',
			DIR . '/includes/datastore',
		);

		$datastore = vB::getDatastore();

		if ($datastore->getOption('storecssasfile'))
		{
			$cssfilelocation = ltrim($datastore->getOption('cssfilelocation'), '/');
			if (!empty($cssfilelocation))
			{
				/*
				We could potentially list all *.css files and only add those
				to the ignoredFiles list so that any non .css files get flagged.

				Also, we may want to only list the subfolders so that the default
				index.html gets scanned. For now, keeping it simple.
				 */
				$defaultIgnoredDirs[] = DIR . '/' . $cssfilelocation;
			}
		}

		if ($datastore->getOption('cache_templates_as_files'))
		{
			// Template path may be absolute OR relative to core.
			$templatefilelocation = $datastore->getOption('template_cache_path');
			if ($templatefilelocation)
			{
				$realTemplateFilelocation = realpath($templatefilelocation);
				if ($realTemplateFilelocation === false)
				{
					$realTemplateFilelocation = realpath(DIR . '/' . $templatefilelocation);
				}
			}

			if ($realTemplateFilelocation)
			{
				$defaultIgnoredDirs[] = $realTemplateFilelocation;
			}
		}



		return $defaultIgnoredDirs;
	}

	public function addIgnoredDir($path)
	{
		if (is_array($path))
		{
			foreach ($path AS $__singlepath)
			{
				$this->addIgnoredDir($__singlepath);
			}
			return;
		}

		// use manual normalize instead of realpath as some directories (like install dir)
		// may not exist but we must exclude it so its record in the checksum manifest
		// doesn't throw an error.
		$path = $this->normalizePath($path);
		if ($path)
		{
			// todo: is_dir check?
			$this->ignoredDirs[$path] = $path;
		}
	}

	public function addIgnoredFile($path)
	{
		if (is_array($path))
		{
			foreach ($path AS $__singlepath)
			{
				$this->addIgnoredFile($__singlepath);
			}
			return;
		}
		$path = $this->normalizePath($path);
		if ($path)
		{
			// todo: is_file check?
			$this->ignoredFiles[$path] = $path;
		}
	}

	public function addAllowedMissingFile($path)
	{
		if (is_array($path))
		{
			foreach ($path AS $__singlepath)
			{
				$this->addAllowedMissingFile($__singlepath);
			}
			return;
		}

		// This function is meant for conditionally ignoring files that are
		// defined in the manifest, like htaccess.txt file which may have been
		// moved or renamed.

		$path = $this->normalizePath($path);
		if ($path)
		{
			// If file doesn't exist on the system add to the ignored list
			// so that we won't report it as missing when verifying the manifest.
			// If file exists, check against manifest.
			if (!realpath($path))
			{
				$this->ignoredFiles[$path] = $path;
			}
		}
	}

	private function setScanRootDir($path)
	{
		$path = realpath($path);
		if (!$path OR !is_dir($path))
		{
			throw new Exception('Option scanRootDir must be a valid directory');
		}

		$this->scanRootDir = $path;
		$this->scanRootLen = strlen($this->scanRootDir);
	}

	private function validateOptions(&$options)
	{
		if (empty($options['checksumFilePrefix']) OR !is_string($options['checksumFilePrefix']))
		{
			throw new Exception('Option checksumFilePrefix must be a valid, nonempty string');
		}

		$options['checksumFileDir'] = realpath($options['checksumFileDir']);
		if (!$options['checksumFileDir'] OR !is_dir($options['checksumFileDir']))
		{
			throw new Exception('Option checksumFileDir must be a valid directory');
		}


		//'scanRootDir' validation is now done in setScanRootDir()

		/*
		$realpathThese = array(
			'ignoredFiles',
			'ignoredDirs',
		);
		We no longer realpath the ignored files & dirs .in case any contains a removed
		folder or file that was specified in the manifest that we need to skip, e.g.
		install directory.
		These paths are now validated via addIgnoredDir() & addIgnoredFile()
		called in the constructor.
		 */


		// remove leading dots and lower-case the extensions
		foreach ($options['extensions'] AS $__key => $__val)
		{
			$options['extensions'][$__key] = strtolower(ltrim($__val, '.'));
		}
	}

	private function isIgnoredDir($fulldir)
	{
		/*
			This is called on directories listed in the checksum manifest.
			As such, it may pass in subdirectories of an ignored ancestor
			directory. E.g. DIR . /install/includes when /install is ignored.

			We have to check all the way up to scanroot.
		 */
		$realpath = realpath($fulldir);
		if ($realpath)
		{
			$fulldir = $realpath;
		}
		else
		{
			$fulldir = $this->normalizePath($fulldir);
		}


		if (isset($this->ignoredDirs[$fulldir]))
		{
			return true;
		}
		else if ($this->scanRootDir == $fulldir)
		{
			return false;
		}

		$parent = $this->getDotDot($fulldir);
		if ($parent AND
			$parent != $fulldir AND
			$parent != DIRECTORY_SEPARATOR
		)
		{
			return $this->isIgnoredDir($parent);
		}

		return false;
	}

	private function registerExpectedDir($fulldir)
	{
		/*
			Some directories are "expected", but only include other directories, not files, so
			may not have an explicit entry in the md5 file.
			E.g. .../clientscript/codemirror/ is an expected directory, but the actual files are
			two levels down so only
				/clientscript/codemirror/addon/dialog
				/clientscript/codemirror/addon/edit
			etc are explitly listed.

			In order to not flag clientscript/codemirror as unexpected but still allow us to check
			for unexpected files in the codemirror directory, for example, we need to include all
			parent directories between scanroot & the specified directory as "known".
		 */
		$relativeDir = $this->removeScanRootFromPath($fulldir);
		// we explode by DIRECTORY_SEPARATOR instead of '/', as although the md5 file was generated on linux
		// and thus hard-code the '/', if we're on windows, the realpath() applied on fulldir before calling
		// this will have resolved it back to the proper separator.
		$relativeDir = ltrim($relativeDir, DIRECTORY_SEPARATOR);
		$parts = explode(DIRECTORY_SEPARATOR, $relativeDir);
		$directory = $this->scanRootDir;
		foreach ($parts AS $part)
		{
			$directory = realpath($directory . DIRECTORY_SEPARATOR . $part);
			if (!isset($this->expectedDirs[$directory]))
			{
				$this->expectedDirs[$directory] = $directory;
			}
		}
	}

	private function processSingleChecksumFile($filepath)
	{
		$filepath = realpath($filepath);
		$baseFilename = basename($filepath);
		// check file prefix again just in case. This is not really sufficient, but I'm not sure what else we can do
		// short of checksums all the way down.
		if (strpos($baseFilename, $this->checksumFilePrefix) !== 0)
		{
			return;
		}

		// I don't like how we just blindly include the file based on prefix... but no way around it?
		include($filepath);
		if ($this->algorithm === 'md5')
		{
			if (isset($scanRoot))
			{
				$this->setScanRootDir($scanRoot);
			}

			if (isset($md5_sums))
			{
				if (empty($md5_sum_softwareid))
				{
					$md5_sum_softwareid = 'vbulletin';
				}

				foreach ($md5_sums AS $__dir => $__relFilenameToDigest)
				{
					$__fullDir = realpath($this->scanRootDir . $__dir);
					if ($__fullDir)
					{
						// This will be used later to not recurse into unexpected directories.
						$this->registerExpectedDir($__fullDir);
					}
					else
					{
						/*
							Install directory exception - the core/install directory is specified
							in the manifest, but not found in live sites because the must remove
							the directory before they can access adminCP.
							At the moment this is handled by admincp/diagnostics.php explicitly
							ignoring the folder for its hashchecker instance.
							Another way to go about it would be to have a separate manifest for
							the install directory that's included by the upgrader's instance of
							hashchecker, and excluded for the diagnostic's instance.
						 */

						if ($this->isIgnoredDir($this->scanRootDir . $__dir))
						{
							/*
								Intentionally not adding this to $this->skippedDirs
								as to prevent any unintended panic by an already deleted
								install directory poltergeisting up in the skipped list
								if we ever output the skipped files & folders.
							 */
						}
						else
						{
							$parentDir = $this->getDotDot($__dir);
							$basename = basename($__dir);
							$this->errors[$parentDir][$basename][] = 'directory_not_found';
						}
						continue;
					}

					foreach ($__relFilenameToDigest AS $__basename => $__digest)
					{
						// realpath() might return false if the file doesn't exist.
						$__unrealPath = $__fullDir . DIRECTORY_SEPARATOR . $__basename;
						$__fullpath = realpath($__fullDir . DIRECTORY_SEPARATOR . $__basename);

						/*
							md5_sums_vbulletin file looks like
							$md5_sums = array(
								'/' => array(
									'api.php' => 'ffda9a585dfcd43c67095d1feebe8de8',
									'attachment.php' => 'aeaf450154d386b932cddabb2a8909a8',
									'css.php' => '834caa6d0090f184efcc9b21966e6199',
									...
							);
							for example. It makes no sense for multiple checksum files to specify
							a different hash for a file for the same algorithm.
						 */
						if (
							isset($this->checksums[$__fullpath]) AND
							$this->checksums[$__fullpath] !== $__digest
						)
						{
							/*
								At the moment we don't keep track of which checksum defined
								which file. Let's just report all of the ones we've processed
								so far.
							 */
							$this->scannedChecksumFiles[$baseFilename] = $baseFilename;

							/*
								Formatting the file list for easier reading in adminCP... but
								it might look worse for commandline upgrades. For web upgrades
								it blends in with the other list items but there shouldn't
								be too many li's if we fail this early.
							 */
							 $checksumFiles = "\n<li>" . implode("</li>\n<li>", $this->scannedChecksumFiles) . "</li>";
							$phraseData = array(
								$__fullDir . DIRECTORY_SEPARATOR . $__basename,
								$checksumFiles,
							);

							throw new vB_Exception_Api('checksum_collision_for_x_in_y', $phraseData);
						}

						// If, for whatever reason, the file is missing, we want to know about it later.
						if ($__fullpath)
						{
							$this->checksums[$__fullpath] = $__digest;
							$this->fileSoftwareAssoc[$__fullpath] = $md5_sum_softwareid;
						}
						else
						{

							if (isset($this->ignoredFiles[$__unrealPath]))
							{
								/*
									Intentionally not adding this to $this->skippedFiles,
									see note above for isIgnoredDir().
								 */
							}
							else
							{
								$parentDir = $this->normalizeDS($__dir);
								$this->errors[$parentDir][$__basename][] = 'file_not_found';
							}
						}
					}
				}

				foreach ($md5_sum_versions AS $__softwareid => $__version)
				{
					$this->versions[$__softwareid] = strtolower($__version);
				}

				$this->scannedChecksumFiles[$baseFilename] = $baseFilename;
				$this->ignoredFiles[$filepath] = $filepath;
			}
			else
			{
				throw new vB_Exception_Api('unable_to_read_md5_sums');
			}
		}
		else
		{
			// todo: figure out how to format other algorithms.
			/*
				Set these:



				$this->expectedDirs[$__fullDir] = $__fullDir;
				$__unrealPath = $__fullDir . '/' . $__basename;
				$__fullpath = realpath($__fullDir . '/' . $__basename);
				if ($__fullpath)
				{
					$this->checksums[$__fullpath] = $__digest;
					$this->fileSoftwareAssoc[$__fullpath] = $md5_sum_softwareid;
				}
				else
				{
					$this->missingFiles[$__unrealPath] = $__unrealPath;
				}


				$this->versions[{softwareid}] = {version};


				$this->scannedChecksumFiles[$baseFilename] = $baseFilename;
				$this->ignoredFiles[$filepath] = $filepath;
			 */
		}
	}

	// md5 files are usually created on a unix box, but may be scanned on
	// either unix or windows.
	// Make all of the paths consistent for key-ing/messaging
	private function normalizeDS($path)
	{
		$path = str_replace('/', DIRECTORY_SEPARATOR, $path);
		$path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
		return $path;
	}

	private function normalizePath($path)
	{
		$path = $this->normalizeDS($path);
		$path = $this->stringClass->normalizepath($path, DIRECTORY_SEPARATOR);
		// vB_Util_String::normalizepath() will re-attach trailing delimiters.
		// We want to mimic realpath() behavior of always excluding trailing
		// delims the best we can.
		$path = rtrim($path, DIRECTORY_SEPARATOR);

		return $path;
	}

	// Get parent directory whether path is real or hypothetical
	private function getDotDot($path)
	{
		$check = realpath($path);
		if ($check)
		{
			return realpath($check . DIRECTORY_SEPARATOR . '..');
		}
		else
		{
			$path = $this->normalizePath($path);
			$lastDS = strrpos($path, DIRECTORY_SEPARATOR);
			if ($lastDS === false)
			{
				// If there was no dir separator, then we're already at the "top" level.
				// Normally this shouldn't happen without a leading slash (handled below),
				// so I'm not sure what the best behavior would be. For now let's just return
				// '', which I think is analogous to returning / or \ below
				return '';
			}
			else if ($lastDS === 0)
			{
				// Note, if $lastDS === 0, that means it's like
				// "/abc" aka "top level". Since "normalized" (root-dir-removed) paths
				// tend to come through here, whose convention parent dir in that case is "/",
				// let's just pass back the dir separator.
				return DIRECTORY_SEPARATOR;
			}

			return substr($path, 0, $lastDS);
		}
	}

	private function removeScanRootFromPath($path)
	{
		// This strips the "scan root" from the full filepaths
		// so that messaging (errors, warnings) will have relative
		// paths to match previous behavior.

		if (!isset($this->relativeDirs[$path]))
		{
			if ($path === $this->scanRootDir)
			{
				// Special case, 'core' (default scan root) is displayed as '/'
				$this->relativeDirs[$path] = DIRECTORY_SEPARATOR;
			}
			else if (strpos($path, $this->scanRootDir) === 0)
			{
				$this->relativeDirs[$path] = substr($path, $this->scanRootLen);
			}
			else
			{
				$this->relativeDirs[$path] = $path;
			}
		}

		return $this->relativeDirs[$path];
	}

	private function processChecksumFiles()
	{
		if (!is_dir($this->checksumFileDir))
		{
			throw new Exception('Option checksumFileDir must be a valid directory');
		}

		$md5_sums_array = array();
		$md5_sum_versions = array('vbulletin' => '5.6.0');
		$file_software_assoc = array();
		$scanned_md5_files = array();

		$checksumsFolderIterator = new DirectoryIterator($this->checksumFileDir);

		foreach($checksumsFolderIterator AS $file)
		{
			if (!$file->isDot())
			{
				if ($file->isDir())
				{
					// todo: check recursively??
					// $temp = $this->getCheckSumFiles($file->getPathname())

					continue;
				}

				//ignore files that don't have the php extension
				//else if (strcasecmp($file->getExtension(), 'php') === 0)
				else if (strpos($file->getFilename(), $this->checksumFilePrefix) === 0)
				{
					if ($file->isReadable())
					{
						// Skipping the isReadable() check. TODO change behavior if include() fails?
						try
						{
							$this->processSingleChecksumFile($file->getPathname());
						}
						catch (vB_Exception_Api $e)
						{
							foreach ($e->get_errors() AS $error)
							{
								$this->fatalErrors[] = $error;
							}
							// Do not process the remaining checksums (if any) and return error to user.
							return;
						}
						if ($file->isWritable())
						{
							// todo: better warning? Also we don't know if we're running as webserver or
							// actually privileged user (e.g. ran upgrade from commandline). In the latter
							// case we're not certain that the webserver user cannot write to this file.
							$this->startupWarnings[] = array('checksum_file_writable', $file->getFilename());
						}
					}
					else
					{
						throw new Exception('Checksum file ' . $file->getPathname() . ' is unreadable!');
					}
				}
			}
		}

		if (empty($this->checksums) OR
			empty(reset($this->checksums)) OR
			!isset($this->scannedChecksumFiles['md5_sums_vbulletin.php'])
		)
		{
			//$this->errors[] = array('unable_to_open_x', 'includes/*');
			$this->fatalErrors[] = 'unable_to_read_md5_sums';
		}
	}

	public function verifyFiles()
	{
		$this->processChecksumFiles();
		if (!empty($this->fatalErrors))
		{
			return array(
				'success' => false,
				'fatalErrors' => $this->fatalErrors,
				'startupWarnings' => $this->startupWarnings,
			);
		}

		$this->recursivelyCompareFilesInDirAgainstChecksums($this->scanRootDir);

		// alphabetically sort everything (directory keys and filename values)
		// since ordering is not guaranteed by DirectoryIterator, and we might
		// insert values at weird times depending on the ignorelist etc.
		$this->sortReturnArray($this->errors);
		$this->sortReturnArray($this->fileCounts);
		$this->sortReturnArray($this->skippedDirs);
		$this->sortReturnArray($this->skippedFiles);
		$this->sortReturnArray($this->scannedChecksumFiles);

		return array(
			'success' => true,
			'errors' => $this->errors,
			'fileCounts' => $this->fileCounts,
			// todo: notify caller with this info for manual review
			'skippedDirs' => $this->skippedDirs,
			'skippedFiles' => $this->skippedFiles,
			'startupWarnings' => $this->startupWarnings,
			'checksumManifests' => $this->scannedChecksumFiles,
		);
	}

	private function sortReturnArray(&$arr, $maxdepth = 2)
	{
		/*
			The return arrays look like
			$this->error[$directory][$filename][] = phrase|phrase-array
			and we only want to sort the $directory & $filename bits, and NOT the
			last phrase array. Stopping at depth 2 default.
		 */
		if (!is_array($arr) OR empty($arr) OR $maxdepth < 1)
		{
			return;
		}

		if (!is_numeric(array_keys($arr)[0]))
		{
			ksort($arr);
		}
		else
		{
			// reset keys for numeric arrays.
			sort($arr);
		}

		foreach ($arr AS $__key => $__val)
		{
			$this->sortReturnArray($__val, ($maxdepth - 1));
			$arr[$__key] = $__val;
		}
	}

	private function recursivelyCompareFilesInDirAgainstChecksums($path)
	{
		/*
			circular symlink protection
			Note on symlinks: we realpath() the ignoredFiles, ignoredDirs, & the keys on
			$this->checkSums (& other related arrays). So even if expected files are
			symlinks, we should be checking it properly against the checksums list. In
			other words, the checks should be more or less blind as to whether an expected
			file is a symlink or a real file (as the old code was).
			However, this has not been heavily tested.
		 */
		$path = realpath($path);
		if (isset($this->checkedDirs[$path]))
		{
			return;
		}
		$this->checkedDirs[$path] = true;

		if (is_dir($path) AND isset($this->expectedDirs[$path]))
		{
			// This was added here to ensure that empty, but recognized
			// directories will have an output row (with Scanned 0 files)
			// If we later decide we don't like this, we can remove this block
			// without affecting the normal (file count > 0) outputs.
			$relativeDir = $this->removeScanRootFromPath($path);
			if (!isset($this->fileCounts[$relativeDir]))
			{
				$this->fileCounts[$relativeDir] = 0;
			}
		}

		$dirIterator = new DirectoryIterator($path);

		foreach($dirIterator AS $file)
		{
			// Skip dots
			if ($file->isDot())
			{
				continue;
			}

			$filepath = $file->getRealPath();
			$filedir = $file->getPath();
			$filename = $file->getFilename();
			$extension = strtolower($file->getExtension());

			/*
				If it's a directory, check if it's expected. Only recursively
				check its contents if it's expected, otherwise flag the entire
				directory for manual review, as to not flood the output with
				every single new file in the unexpected directory (e.g. when
				using css/templates as files with the css/template directory
				inside of the scan root)
			 */
			if ($file->isDir())
			{
				$relativeDir = $this->removeScanRootFromPath($filepath);
				$parentDir = $this->getDotDot($relativeDir);

				if (isset($this->ignoredDirs[$filepath]))
				{
					// $this->errors[$parentDir][$filename][] = 'directory_skipped';
					$this->skippedDirs[$parentDir][] = $filename;
					continue;
				}

				if (!isset($this->expectedDirs[$filepath]))
				{
					$this->errors[$parentDir][$filename][] = 'directory_not_recognized';
					continue;
				}

				// If it's known & not ignored, recursively check inside the folder.
				$this->recursivelyCompareFilesInDirAgainstChecksums($filepath);
			}
			else
			{
				$this->checkSingleFileAgainstChecksums($file);
			}
		}
	}

	private function checkSingleFileAgainstChecksums($file)
	{
		$filepath = $file->getRealPath();
		$filedir = $file->getPath();
		$relativeDir = $this->removeScanRootFromPath($filedir);
		$filename = $file->getFilename();
		$extension = strtolower($file->getExtension());

		// skip ignored files, unchecked extensions, and "hidden files" (filenames start
		// with dot, like .htaccess), and don't "count" them.
		if (
			isset($this->ignoredFiles[$filepath]) OR
			!isset($this->checkedExtensions[$extension]) OR
			// Skip .* files (except for specified ones like .htaccess)
			$filename[0] === '.' AND !isset($this->checkedExtensions[$extension])
		)
		{
			// $this->errors[$relativeDir][$filename][] = 'file_skipped';
			$this->skippedFiles[$relativeDir][] = $filename;
			return;
		}


		if (!isset($this->fileCounts[$relativeDir]))
		{
			$this->fileCounts[$relativeDir] = 0;
		}
		$this->fileCounts[$relativeDir]++;


		/*
			Special case - if index.html, ensure it's an empty file and move on.
			Empty index.html files are "expected" (or at least, likely harmless)
			but they are not included in the checksums list, thus this snowflake
			code block. However, there are some non-empty index.html files that
			need to go through the hash check.
			One change in behavior to check for isReadable() . . .
		 */
		if ($filename == 'index.html')
		{
			if ($file->isReadable())
			{
				if (trim(file_get_contents($filepath)) === '')
				{
					return;
				}
				else
				{
					// There are a few index.html that actually *are* included in the checksums list.
				}
			}
			else
			{
				$this->errors[$relativeDir][$filename][] = 'file_not_readable';
				return;
			}
			// If we're here, it's a non-empty one that needs to be vetted below.
		}


		// Flag unexpected files
		if (!isset($this->checksums[$filepath]))
		{
			$this->errors[$relativeDir][$filename][] = 'file_not_recognized';
			return;
		}

		if ($file->isReadable())
		{
			$version = $this->getVersionFromContents($file);
			$softwareid = $this->fileSoftwareAssoc[$filepath] ?? '';
			if ($extension == 'php' OR $extension == 'js')
			{
				if ($version AND isset($this->versions[$softwareid]))
				{
					if ($version !== $this->versions[$softwareid])
					{
						$this->errors[$relativeDir][$filename][] = array(
							'file_version_mismatch_x_expected_y',
							$this->stringClass->htmlspecialchars($version),
							$this->stringClass->htmlspecialchars($this->versions[$softwareid]),
						);

						return;
					}
				}
				else
				{
					// If we don't have a version, it may be that the file doesn't have the version string
					// in the first 10 lines. Previous checks allowed such cases.
				}
			}
			else if ($extension == 'phar')
			{
				if (!isset($this->versions[$softwareid]) OR
					$version !== $this->versions[$softwareid]
				)
				{
					// Phar files aren't allowed to skip the version check.
					//$this->misversionedFiles[$filepath] = $filepath;
					$this->errors[$relativeDir][$filename][] = array(
						'file_version_mismatch_x_expected_y',
						$this->stringClass->htmlspecialchars($version),
						$this->stringClass->htmlspecialchars($this->versions[$softwareid]),
					);

					return;
				}
			}

			// If we got here, we either passed the version compare or didn't need to version compare.
			$realDigest = hash($this->algorithm, str_replace("\r\n", "\n", file_get_contents($filepath)));
			if (empty($realDigest) OR $realDigest !== $this->checksums[$filepath])
			{
				$this->errors[$relativeDir][$filename][] = 'file_contents_mismatch';
			}
		}
		else
		{
			$this->errors[$relativeDir][$filename][] = 'file_not_readable';
		}

	}


	private function getVersionFromContents($file)
	{
		$filedir = $file->getPath();
		$filename = $file->getFilename();
		$filepath = $file->getPathname();
		$extension = strtolower($file->getExtension());

		if (
			($extension == 'php' OR $extension == 'js') AND
			 $fp = @fopen($filepath, 'rb')
		)
		{
			$linenumber = 0;
			$finished = false;
			$matches = array();

			while ($line = fgets($fp, 4096) AND $linenumber <= 10)
			{
				if ($extension == 'php' AND preg_match('#\|\| \# vBulletin[^0-9]* (\d.*?|\[\#\]version\[\#\]) -#si', $line, $matches))
				{
					$finished = true;
				}
				else if (preg_match('#^\|\| \# vBulletin[^0-9]* (\d.*|\[\#\]version\[\#\])$#si', $line, $matches))
				{
					$finished = true;
				}

				$linenumber++;

				if ($finished)
				{
					fclose($fp);
					return strtolower(trim($matches[1]));
				}
			}
			fclose($fp);
		}
		else if ($extension == 'phar')
		{
			if (file_exists("$filepath") AND
				Phar::isValidPharFilename("$filepath"))
			{
				$phar = new Phar("$filepath");
				$meta = $phar->getMetadata();
				if (!empty($meta['version']))
				{
					return strtolower($meta['version']);
				}
			}
		}

		return '';
	}



}

/*=========================================================================*\
|| #######################################################################
|| # NulleD By - vBSupport.org
|| # CVS: $RCSfile$ - $Revision: 103796 $
|| #######################################################################
\*=========================================================================*/
